        -:    0:Source:randomtestadventurer.c
        -:    0:Graph:randomtestadventurer.gcno
        -:    0:Data:randomtestadventurer.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include <string.h>
        -:    4:#include <stdio.h>
        -:    5:#include <assert.h>
        -:    6:#include <math.h>
        -:    7:#include <stdlib.h>
        -:    8:#include <time.h>
        -:    9:#include "rngs.h"
        -:   10:
        -:   11:
        -:   12:
        -:   13:#define DEBUG 0
        -:   14:#define NOISY_TEST 1
        -:   15:
        -:   16:int refactorAdventurer(int drawntreasure, struct gameState *state, int currentPlayer, int cardDrawn, int z, int *temphand);
        -:   17:
        -:   18:/*
        -:   19:Reveal cards from your deck until you reveal 2 treasure cards. put those treasure cards into your hand and discard other revealed cards
        -:   20:To random test:
        -:   21:	drawntreasure - not enough treasures in deck?
        -:   22:	gamestate struct
        -:   23:	current player int (compatible number)
        -:   24:	cardDrawn
        -:   25:	z
        -:   26:	*temphand
        -:   27:
        -:   28:  while(drawntreasure<2){
        -:   29:  if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
        -:   30:    shuffle(currentPlayer, state);
        -:   31:  }
        -:   32:  drawCard(currentPlayer, state);
        -:   33:  cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
        -:   34:  if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
        -:   35:    drawntreasure++;
        -:   36:  else{
        -:   37:    temphand[z]=cardDrawn;
        -:   38:    state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
        -:   39:    z++;
        -:   40:  }
        -:   41:      }
        -:   42:      while(z-1>=0){
        -:   43:  state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
        -:   44:  z=z-1;
        -:   45:      }
        -:   46:      return 0;
        -:   47:      
        -:   48:}
        -:   49:*/
        -:   50:/*
        -:   51:struct gameState {
        -:   52:  int numPlayers; //number of players
        -:   53:  int supplyCount[treasure_map+1];  //this is the amount of a specific type of card given a specific number.
        -:   54:  int embargoTokens[treasure_map+1];
        -:   55:  int outpostPlayed;
        -:   56:  int outpostTurn;
        -:   57:  int whoseTurn;
        -:   58:  int phase;
        -:   59:  int numActions; //Starts at 1 each turn 
        -:   60:  int coins; // Use as you see fit! 
        -:   61:  int numBuys; // Starts at 1 each turn 
        -:   62:  int hand[MAX_PLAYERS][MAX_HAND];
        -:   63:  int handCount[MAX_PLAYERS];			   --use this
        -:   64:  int deck[MAX_PLAYERS][MAX_DECK];
        -:   65:  int deckCount[MAX_PLAYERS];              --use this
        -:   66:  int discard[MAX_PLAYERS][MAX_DECK];	   --use this
        -:   67:  int discardCount[MAX_PLAYERS];
        -:   68:  int playedCards[MAX_DECK];
        -:   69:  int playedCardCount;
        -:   70:};
        -:   71:
        -:   72:****Also check 
        -:   73:
        -:   74:*/
        -:   75:
        -:   76:
        -:   77:
        -:   78:int main(){
        -:   79:	
        -:   80:	struct gameState *game;
        -:   81:
        -:   82:	int i, j;
        1:   83:	int k[10] = {adventurer, council_room, feast, gardens, mine,
        -:   84:	       remodel, smithy, village, baron, great_hall};
        -:   85:	//adventurecard specific variables
        -:   86:	//int drawntreasure=0; //can have this be > 1 for testing
        1:   87:	int player=0;
        1:   88:	int errors=0;
        -:   89:
        -:   90:
        1:   91:	printf("Testing adventurer card. \n");
        1:   92:	printf("RANDOM TESTS. \n");
        1:   93:	int iterations = 100;
        1:   94:	int treasures[] = {copper, silver, gold};
        -:   95:
        -:   96:
        -:   97:
        1:   98:	srand(time(NULL));
        -:   99:
      202:  100:	for (i=0; i < iterations; i++){
      100:  101:		game = malloc(sizeof(struct gameState));
      100:  102:		int players = rand() % 3 + 2;
        -:  103:		
        -:  104:
      100:  105:		printf("Test %d Init\n", i+1);
        -:  106:
      100:  107:		initializeGame(players, k, rand(), game);
        -:  108:
        -:  109:		//initialized the player's handcount, deckcount, and discard count, and we want to keep track of it
      100:  110:		game->handCount[player] = rand() % MAX_DECK;
      100:  111:		game->deckCount[player] = rand() % MAX_DECK;
      100:  112:		game->discardCount[player] = rand() % MAX_DECK;
      100:  113:		int treasureCount = 0;
        -:  114:
        -:  115:		//refactorAdventurer(int drawntreasure, struct gameState *state, int currentPlayer, int cardDrawn, int z, int *temphand)
      100:  116:		printf("Before Init\n");
      100:  117:		printf("handcount: %d\n", game->handCount[player]);
      100:  118:		printf("deckcount: %d\n", game->deckCount[player]);
      100:  119:		printf("discardcount: %d\n", game->deckCount[player]);
        -:  120:
    49802:  121:		for (j=0; j < game->handCount[player]; j++){
    42275:  122:			if( (game->hand[player][j] == treasures[0]
    42275:  123:				|| game->hand[player][j] == treasures[1]
    34948:  124:				|| game->hand[player][j] == treasures[2]) ){
     7327:  125:				treasureCount++;
     7327:  126:			}
    24801:  127:		}
      100:  128:		printf("treasureCOUNT: %d\n", treasureCount);
        -:  129:
      100:  130:		cardEffect(adventurer, 1, 1, 1, game, 0, 0);
        -:  131:		//adventurer card goes into effect
        -:  132:
    50800:  133:		for (j=0; j < game->handCount[player]; j++){
    42865:  134:			if( (game->hand[player][j] == treasures[0]
    42865:  135:				|| game->hand[player][j] == treasures[1]
    35130:  136:				|| game->hand[player][j] == treasures[2]) ){
     7735:  137:				treasureCount = treasureCount - 1;
     7735:  138:			}
    25300:  139:		}
        -:  140:
      100:  141:		if(treasureCount >= -1){ //after the adventurer card is used, in best case the first two cards will be a treasure card.
        1:  142:			errors++;
        1:  143:			printf("***ERROR FOUND");
        1:  144:		}
        -:  145:
        -:  146:
      100:  147:		printf("After Init\n");
      100:  148:		printf("handcount: %d\n", game->handCount[player]);
      100:  149:		printf("deckcount: %d\n", game->deckCount[player]);
      100:  150:		printf("discardcount: %d\n", game->deckCount[player]);
      100:  151:		printf("treasureCOUNT: %d\n", treasureCount);
        -:  152:		
      100:  153:		free(game);
      100:  154:	}
        -:  155:
        1:  156:	printf("\n");
        1:  157:	printf("The number of errors was: %d\n", errors);
        -:  158:
        1:  159:	if (errors > 0){
        1:  160:		printf("\n **Test completed with errors\n");
        1:  161:	}
        -:  162:	else{
    #####:  163:		printf("\n **Test complete with no errors\n");
        -:  164:	}
        -:  165:
        -:  166:	//use cardEffect to run the card and it's effect onto gamestate game
        -:  167:
        -:  168:	
        -:  169:
        1:  170:	return 0;
        -:  171:}
        -:  172:
        -:  173:
        -:  174:
        -:  175:
        -:  176:
        -:  177:
        -:  178:
        -:  179:
        -:  180:
        -:  181:
        -:  182:
